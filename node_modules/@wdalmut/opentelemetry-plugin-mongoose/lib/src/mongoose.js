"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@opentelemetry/core");
const shimmer = __importStar(require("shimmer"));
const enums_1 = require("./enums");
const utils_1 = require("./utils");
const version_1 = require("./version");
const contextCaptureFunctions = [
    'remove',
    'deleteOne',
    'deleteMany',
    'find',
    'findOne',
    'estimatedDocumentCount',
    'countDocuments',
    'count',
    'distinct',
    'where',
    '$where',
    'findOneAndUpdate',
    'findOneAndDelete',
    'findOneAndReplace',
    'findOneAndRemove',
];
// when mongoose functions are called, we store the original call context
// and then set it as the parent for the spans created by Query/Aggregate exec()
// calls. this bypass the unlinked spans issue on thenables await operations (issue #29)
exports._STORED_PARENT_SPAN = Symbol('stored-parent-span');
class MongoosePlugin extends core_1.BasePlugin {
    constructor(moduleName) {
        super('@wdalmut/opentelemetry-plugin-mongoose', version_1.VERSION);
        this.moduleName = moduleName;
    }
    patch() {
        this._logger.debug('MongoosePlugin: patch mongoose plugin');
        shimmer.wrap(this._moduleExports.Model.prototype, 'save', this.patchOnModelMethods('save'));
        shimmer.wrap(this._moduleExports.Model.prototype, 'remove', this.patchOnModelMethods('remove'));
        shimmer.wrap(this._moduleExports.Query.prototype, 'exec', this.patchQueryExec());
        shimmer.wrap(this._moduleExports.Aggregate.prototype, 'exec', this.patchAggregateExec());
        contextCaptureFunctions.forEach((funcName) => {
            shimmer.wrap(this._moduleExports.Query.prototype, funcName, this.patchAndCaptureSpanContext(funcName));
        });
        shimmer.wrap(this._moduleExports.Model, 'aggregate', this.patchModelAggregate());
        return this._moduleExports;
    }
    patchAggregateExec() {
        const thisPlugin = this;
        thisPlugin._logger.debug('MongoosePlugin: patched mongoose Aggregate exec prototype');
        return (originalExec) => {
            return function exec() {
                var _a, _b;
                const parentSpan = this[exports._STORED_PARENT_SPAN];
                let span = utils_1.startSpan(thisPlugin._tracer, (_a = this._model) === null || _a === void 0 ? void 0 : _a.modelName, 'aggregate', parentSpan);
                span.setAttributes(utils_1.getAttributesFromCollection(this._model.collection));
                span.setAttribute(enums_1.AttributeNames.DB_QUERY_TYPE, 'aggregate');
                span.setAttribute(enums_1.AttributeNames.DB_OPTIONS, JSON.stringify(this.options));
                span.setAttribute(enums_1.AttributeNames.DB_AGGREGATE_PIPELINE, JSON.stringify(this._pipeline));
                const aggregateResponse = originalExec.apply(this, arguments);
                return utils_1.handleExecResponse(aggregateResponse, span, (_b = thisPlugin === null || thisPlugin === void 0 ? void 0 : thisPlugin._config) === null || _b === void 0 ? void 0 : _b.enhancedDatabaseReporting);
            };
        };
    }
    patchQueryExec() {
        const thisPlugin = this;
        thisPlugin._logger.debug('MongoosePlugin: patched mongoose Query exec prototype');
        return (originalExec) => {
            return function exec() {
                var _a;
                const parentSpan = this[exports._STORED_PARENT_SPAN];
                let span = utils_1.startSpan(thisPlugin._tracer, this.model.modelName, this.op, parentSpan);
                span.setAttributes(utils_1.getAttributesFromCollection(this.mongooseCollection));
                span.setAttribute(enums_1.AttributeNames.DB_QUERY_TYPE, this.op);
                span.setAttribute(enums_1.AttributeNames.DB_STATEMENT, JSON.stringify(this._conditions));
                span.setAttribute(enums_1.AttributeNames.DB_OPTIONS, JSON.stringify(this.options));
                span.setAttribute(enums_1.AttributeNames.DB_UPDATE, JSON.stringify(this._update));
                const queryResponse = originalExec.apply(this, arguments);
                return utils_1.handleExecResponse(queryResponse, span, (_a = thisPlugin === null || thisPlugin === void 0 ? void 0 : thisPlugin._config) === null || _a === void 0 ? void 0 : _a.enhancedDatabaseReporting);
            };
        };
    }
    patchOnModelMethods(op) {
        const thisPlugin = this;
        thisPlugin._logger.debug(`MongoosePlugin: patched mongoose Model ${op} prototype`);
        return (originalOnModelFunction) => {
            return function method(options, fn) {
                var _a;
                let span = utils_1.startSpan(thisPlugin._tracer, this.constructor.modelName, op);
                span.setAttributes(utils_1.getAttributesFromCollection(this.constructor.collection));
                span.setAttribute(enums_1.AttributeNames.DB_QUERY_TYPE, op);
                if ((_a = thisPlugin === null || thisPlugin === void 0 ? void 0 : thisPlugin._config) === null || _a === void 0 ? void 0 : _a.enhancedDatabaseReporting) {
                    span.setAttribute(enums_1.AttributeNames.DB_SAVE, utils_1.safeStringify(this));
                }
                if (options instanceof Function) {
                    fn = options;
                    options = undefined;
                }
                if (fn instanceof Function) {
                    return originalOnModelFunction.apply(this, [options, (err, product) => {
                            if (err) {
                                utils_1.setErrorStatus(span, err);
                            }
                            span.end();
                            return fn(err, product);
                        }]);
                }
                else {
                    return originalOnModelFunction.apply(this, arguments)
                        .catch(utils_1.handleError(span))
                        .finally(() => span.end());
                }
            };
        };
    }
    // we want to capture the otel span on the object which is calling exec.
    // in the special case of aggregate, we need have no function to path
    // on the Aggregate object to capture the context on, so we patch
    // the aggregate of Model, and set the context on the Aggregate object
    patchModelAggregate() {
        const thisPlugin = this;
        thisPlugin._logger.debug(`MongoosePlugin: patched mongoose model aggregate`);
        return (original) => {
            return function captureSpanContext() {
                const currentSpan = thisPlugin._tracer.getCurrentSpan();
                const aggregate = original.apply(this, arguments);
                if (aggregate)
                    aggregate[exports._STORED_PARENT_SPAN] = currentSpan;
                return aggregate;
            };
        };
    }
    patchAndCaptureSpanContext(funcName) {
        const thisPlugin = this;
        thisPlugin._logger.debug(`MongoosePlugin: patched mongoose query ${funcName} prototype`);
        return (original) => {
            return function captureSpanContext() {
                this[exports._STORED_PARENT_SPAN] = thisPlugin._tracer.getCurrentSpan();
                return original.apply(this, arguments);
            };
        };
    }
    unpatch() {
        this._logger.debug('MongoosePlugin: unpatch mongoose plugin');
        shimmer.unwrap(this._moduleExports.Model.prototype, 'save');
        shimmer.unwrap(this._moduleExports.Model.prototype, 'remove');
        shimmer.unwrap(this._moduleExports.Query.prototype, 'exec');
        contextCaptureFunctions.forEach((funcName) => {
            shimmer.unwrap(this._moduleExports.Query.prototype, funcName);
        });
        shimmer.unwrap(this._moduleExports.Model, 'aggregate');
    }
}
exports.MongoosePlugin = MongoosePlugin;
exports.plugin = new MongoosePlugin('mongoose');
//# sourceMappingURL=mongoose.js.map